~~ Copyright 2002-2008 CS Communication & Syst√®mes
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~   http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.

Propagation

  This package provides tools to propagate orbital states with different methods.
	
* Propagation Presentation

  Propagation is the prediction of the evolution of a system from an initial state.
  In Orekit, this initial state is represented by a <SpacecraftState>, which is a 
  simple container for all needed information : orbit, mass, kinematics, attitude, date, 
  frame.

** Propagation modes

  Depending on the needs of the calling application, all propagators can be used in
  different modes:
 
   * slave mode: This mode is used when the user needs only the final orbit at the target 
  time. The (slave) propagator is passive: it computes this result and return it to the 
  calling (master) application, without any intermediate feedback. In that case the events 
  detection is made but the <step handler> does nothing, actions are managed directly by the
  calling application.


   * master mode: This mode is used when the user needs to have some custom function 
  called at the end of each finalized step during integration. The (master) propagator 
  is active: the integration loop calls the (slave) application callback methods at each 
  finalized step, through the <step handler>.


   * ephemeris generation mode: This mode is used when the user needs random access 
  to the orbit state at any time between the initial and target times, and in no
  sequential order. A typical example is the implementation of search and iterative 
  algorithms that may navigate forward and backward inside the propagation range before 
  finding their result.
  Beware that this mode cannot support events that modify spacecraft initial state. 
  Beware that since this mode stores <<all>> intermediate results, it may be memory 
  intensive for long integration ranges and high precision/short time steps.


** Events management

  All propagators, including analytical ones, support discrete events handling during
  propagation. This feature is activated by registering events detectors as defined by
  the <EventDetector> interface to the propagator. At each propagation step, the
  propagator checks the registered events detectors for the occurrence of some event.
  If an event occurs, then the corresponding action is triggered, which can ask the
  propagator to resume propagation, possibly with an updated state or to stop propagation.

  Resuming propagation with changed state is used for example in the <ImpulseManeuver>
  class. When the maneuver is triggered, the orbit is changed according to the velocity increment
  associated with the maneuver and the mass is reduced according to the consumption. This
  allows to handle simple maneuvers transparently even inside basic propagators like
  Kepler or Eckstein-Heschler.

  Stopping propagation is useful when some specific state is desired but its real occurrence
  time is unknown in advance. a typical example would be to find the next ascending node
  or the next apogee. In this case, we can register a <NodeDetector> or an <ApsideDetector>
  object and launch a propagation with a target time far away in the future. When the
  event is triggered, it ask the propagator to stop and the returned value is the state
  exactly at the event time.

  Two other available events detectors are a simple <DateDetector> which is simply tirggered
  at a predefined date and an <ElevationDetector> which is triggered at raising or setting
  time of a satellite with respect to a ground point. The latter can be used to compute
  easily operational forecasts.


* Available propagators


** Keplerian propagation

 The <KeplerianPropagator> implements the <Propagator> interface, which ensures 
 that we can obtain a propagated SpacecraftState at any time once the instance 
 is initialized with an initial state. This model is based on Keplerian only
 motion. It depends on \u00b5.


** Eckstein-Hechler propagation	

  This analytical model is suited for near circular orbits and inclination neither 
  equatorial nor critical. It considers J2 to J6 potential zonal coefficients, 
  and uses mean parameters to compute the new position. As the keplerian propagator, 
  it implements the <Propagator> interface. 

	
** Numerical propagation

  It is the most important part of the OREKIT project. Based on commons-math
  integrators, the <NumericalPropagator> class realizes the interface between 
  space mechanics and mathematical resolutions. If its utilization seems difficult 
  on first sight, it is in  fact quite clear and intuitive.


  The mathematical problem to integrate is a dimension seven time derivative equations
  system. The six first equations are given by the Gauss equations (expressed
  in <EquinoctialOrbit>) and the seventh one is simply the flow rate for mass evolution
  during maneuvers. This first order system is computed by the <TimeDerivativesEquations>
  class. It will be instanced by the propagator and then be modified at each step 
  (a fixed t value) by all the needed force models which will add their contribution, 
  the perturbing acceleration.
 
  The integrators (<first order integrators>) provided by commons-math need 
  the state vector at t0, the state vector first time derivative at t0,
  and then calculates the next step state vector, and ask for the next first 
  time derivative, etc. until it reaches the final asked date. 


* Authors

  ** Luc Maisonobe
  
  ** Fabien Maussion
  